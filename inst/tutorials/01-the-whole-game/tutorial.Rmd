---
title: The Whole Game
author: David Kane and Matthew Ru
tutorial:
  id: the-whole-game
output:
  learnr::tutorial:
    progressive: yes
    allow_skip: yes
runtime: shiny_prerendered
description: 'Tutorial for Chapter 1: The Whole Game'
---

```{r setup, include = FALSE}
library(learnr)
library(tutorial.helpers)
library(devtools)
knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 60, 
        tutorial.storage = "local") 

strsplit1 <- function(x, split) {
  strsplit(x, split = split)[[1]]
}
```

```{r copy-code-chunk, child = system.file("child_documents/copy_button.Rmd", package = "tutorial.helpers")}
```

```{r info-section, child = system.file("child_documents/info_section.Rmd", package = "tutorial.helpers")}
```

<!-- Some notes: -->

<!-- We need not mimic everything that this chapter does. It may be useful to do different things in a different order. -->

<!-- In particular, we will often add extra questions to something which is, originally, a single line of code in the book. That is, we will run something like use_testhat() and then have 6 questions which examine/explain all the changes that this one command caused in the package --- it changes the DESCRIPTION file, it creates the tests directory, it creates the tests/testthat.R script (and let's explain all the lines in that file), and so on. We want a question for each of the changes, even if that question is just readLines(something, something). -->

<!-- One example of a major change is, I think, that the Start with Github (see Happy Ruser book) approach is better than what they do. That is, the first step is to create a Github repo and then connect it to a new R project. -->

## Introduction
### 

This tutorial covers [Chapter 1: The Whole Game](https://r-pkgs.org/whole-game.html) from [*R Packages (2e)*](https://r-pkgs.org/) by [Hadley Wickham](https://hadley.nz/) and [Jennifer Bryan](https://jennybryan.org/). [**devtools**](https://devtools.r-lib.org/) is a package designed to make package development easier by providing R functions that simplify and expedite common tasks.

## Connect RStudio to Git and Github
### 

Visit [Github](https://github.com) and make sure you are logged in. If you do not have a Github account, you can look at the RStudio and Github tutorial from `r4ds.tutorials`.

### Exercise 1

We are going to create a new repository, so click the big green "New" button next to "Repositories".

### Exercise 2

Name your repo `regexcite`.

### Exercise 3

Select the "Public" option for your repo.

### Exercise 4

Lastly, check the box next to "Add a README file" and click the green "Create repository" button.

### 

Recall that a README file is a document where programmers often add or explain details of their project. Visit <https://en.wikipedia.org/wiki/README> for more information.

### Exercise 5

Once you have created your repository, copy the URL of the project page and paste it below. The link should look something like this: `https://github.com/username/repo-name`.

```{r connect-rstudio-to-g-5}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

You may have noticed that we did not specify a `.gitignore` template. We will not have to worry about this setting because RStudio always creates a `.gitignore` file for us.

### Exercise 6

Now, clone the repo by first clicking the big green "Code" button and copying the https link shown.

### 

Paste the link here. It should end in `.git`.

```{r connect-rstudio-to-g-6}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

This link directs to your github project and is a little different from the website URL because the `.git` ending identifies it as a special Github object.

### Exercise 7

Create a new RStudio Project. Visit "File" at the upper left corner and click "New Project". From there, click "Version Control" and select "Git". Now, paste in the `.git` link you copied earlier in the field "Repository URL:". Take note of your project directory, click "Open in new session" and press "Create Project".

### 

### Exercise 8

Open up the Terminal in your new project and type `ls -a`. CP/CR.

```{r connect-rstudio-to-g-8}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

Note the `.Rproj` file that represents your project and the `.gitignore` file that RStudio automatically created.

### Exercise 9

Open up the `.gitignore` file and add `*.Rproj` to the bottom of the file. Save the file.

### 

In the Terminal, run `cat .gitignore`. CP/CR.

```{r connect-rstudio-to-g-9}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

Adding the `*.Rproj` line to the `.gitignore` file tells the computer that we want to avoid uploading all files ending with `.Rproj`. We do not want to include the `.Rproj` file because it mostly contains local settings that are irrelevant to the repository.

### Exercise 10

Now that we have made changes to the `.gitignore` file, click the "Git" tab in the upper righthand corner and select the box on the left of `.gitignore` to stage your changes.

### Exercise 11

Once you have staged them, press the "Commit" button, type an initial commit message (e.g. "Initial Commit"), and press commit.

### 

Note that commit messages do not need to be long and complete sentences, just a few words that summarizes what the edits achieved.

### Exercise 12

Run `gert::git_ahead_behind()$ahead` in the Console. CP/CR

```{r connect-rstudio-to-g-12}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

You should have gotten the number `1`. This means you have one commit out of sync with the remote Github project.

### Exercise 13

Type `git log` in the Terminal. CP/CR.

```{r connect-rstudio-to-g-13}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

`git log` shows your commit history. You should see the commit message, Github username, and timestamp for your initial commit.

### Exercise 14

Finally, press the green "Push" button to push your changes to Github.

### 

Again, run `gert::git_ahead_behind()$ahead` in the Console to make sure you pushed your changes. CP/CR.

```{r connect-rstudio-to-g-14}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

This should return `0` meaning that there are `0` changes out of sync with Github, so everything is up-to-date.

## Load devtools and friends
### Exercise 1

Load the **devtools** library with `library()` in the Console. CP/CR.

```{r load-devtools-and-fr-1}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

**devtools** is the public face of a set of packages that support various aspects of package development. Many of our commands will come from **usethis** and **devtools** is a convenient way to load everything we need at once.

### Exercise 2

Run `packageVersion("devtools")` in the Console to check your version of **devtools**. CP/CR.

```{r load-devtools-and-fr-2}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

Your version should be at least `r packageVersion("devtools")`. Upgrade your version if necessary using `install.packages("devtools")`.

### Exercise 3

Run `getwd()` in the Console and CP/CR.

```{r load-devtools-and-fr-3}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

This is the path to the current project directory which we will use shortly. You can also achieve the same output with `pwd` in the Terminal.

### Exercise 4

Run the `create_package()` command in the Console to initialize a new package in a directory on your computer. Use the path to your project directory that we found in the previous exercise as the argument like this: `create_package("path/to/regexcite")`. CP/CR.

```{r load-devtools-and-fr-4}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

It will prompt you if you want to overwrite the `.Rproj` file, select "Yes". (This will put you in a new RStudio Session).

### Exercise 5

Run `library()` again to reload in **devtools** since `create_package()` has put you in a new R sesssion.

### 

We will be writing a toy package called **regexcite** and it contains a couple of functions that make common tasks with regular expressions easier. Although this is just to demonstrate the typical workflow for package development, we encourage you to preview the finished product on Github: <https://github.com/jennybc/regexcite>.

### Exercise 6

Run `ls -a` in the Terminal of your new session and take note of all the new files `create_package()` has created. CP/CR

```{r load-devtools-and-fr-6}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

You should see new `.Rbuildignore`, `NAMESPACE`, `DESCRIPTION` files and a new `R` directory.

### Exercise 7

Run `cat .Rbuildignore` in the Terminal and CP/CR.

```{r load-devtools-and-fr-7}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

`.Rbuildignore` lists files that we need to have around but should not be included when building the R package from source.

### Exercise 8

Run `cat DESCRIPTION` in the Terminal and CP/CR.

```{r load-devtools-and-fr-8}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

`DESCRIPTION` provides metadata about your package. We will edit this shortly.

### Exercise 9

Run `cat NAMESPACE` in the Terminal and CP/CR.

```{r load-devtools-and-fr-9}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

`NAMESPACE` declares the functions your package exports for external use and the external functions your package imports from other packages. At this point, it is empty, except for a comment declaring that this is a file you should not edit by hand.

### Exercise 10

Run `ls R` to list all the files in the new `R` directory (there are none).

```{r load-devtools-and-fr-10}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

The `R/` directory is the "business end" of your package. It will soon contain `.R` files with function definitions.

### Exercise 11

Check all the boxes under the Git tab to stage all changes, press "Commit", and write a commit message (e.g. "Created Package"). Finally, press "Commit" and "Push". Backing up work on Github allows you to keep your progress if your local computer fails or you accidentally deleted important files locally.

### Exercise 12

Run `gert::git_ahead_behind()$ahead` again in the Console to make sure you pushed your changes. CP/CR.

```{r load-devtools-and-fr-12}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

Once again, this should show that there are `0` changes out of sync with Github.

## Write the first function
### 

### Exercise 1

Set the variable `x` to the string `"alfa,bravo,charlie,delta"`.


```{r write-the-first-func-1, exercise = TRUE}

```

```{r write-the-first-func-1-hint-1, eval = FALSE}
... <- "alfa,bravo,charlie,delta"
```

```{r, include=FALSE}
x <- "alfa,bravo,charlie,delta"
```

### 

The goal of this toy package is to create functions that make common tasks easier. We will not be focusing on the actual helper functions, so if you want to check out more, take a look at **stringr**, **stringi**, **rex**, or **rematch2**.

### Exercise 2

Use the command `strsplit()` with `x` as the first argument.

```{r write-the-first-func-2, exercise = TRUE}
x <- "alfa,bravo,charlie,delta"

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r write-the-first-func-2-hint-1, eval = FALSE}
x <- "alfa,bravo,charlie,delta"
strsplit(...)
```

Note this results in an error because we are missing the second argument, `split`.

### Exercise 3

Copy the previous code and add an argument, setting `split` to `","`.

```{r write-the-first-func-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r write-the-first-func-3-hint-1, eval = FALSE}
x <- "alfa,bravo,charlie,delta"
strsplit(x, split = ...)
```

```{r, include=FALSE}
x <- "alfa,bravo,charlie,delta"
strsplit(x, split = ',')
```

### 

Notice how we input a character vector of length one and we output a list of length one.

### Exercise 4

Let's copy the previous code and take a closer look at the output with the `str()` function. 

```{r write-the-first-func-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r write-the-first-func-4-hint-1, eval = FALSE}
x <- "alfa,bravo,charlie,delta"
...(strsplit(x, split = ","))
```

```{r, include=FALSE}
x <- "alfa,bravo,charlie,delta"
str(strsplit(x, split = ','))
```

### 

We really just want the output to be the character vector of its split up parts. This leads R users to employ various methods of “unlist”-ing the result.

### Exercise 5

Copy the code from Exercise 3 and Use the `unlist()` function on the output of `strsplit()`.

```{r write-the-first-func-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r write-the-first-func-5-hint-1, eval = FALSE}
x <- "alfa,bravo,charlie,delta"
...(strsplit(x, split = ","))
```

```{r, include=FALSE}
x <- "alfa,bravo,charlie,delta"
unlist(strsplit(x, split = ','))
```

### 

The command `unlist()` simplifies a list structure into a vector. Visit the help page by typing `?unlist` into the console for more.

### Exercise 6

Use the `length()` function on the output of the previous code exercise.

```{r write-the-first-func-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r write-the-first-func-6-hint-1, eval = FALSE}
x <- "alfa,bravo,charlie,delta"
...(unlist(strsplit(x, split = ',')))
```

```{r, include=FALSE}
x <- "alfa,bravo,charlie,delta"
length(unlist(strsplit(x, split = ',')))
```

### 

Note how the `unlist()` function has given us a vector of length 4.

### Exercise 7

Copy the code from Exercise 3 and add `[[1]]` to the end of the `strsplit()` line.

```{r write-the-first-func-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r write-the-first-func-7-hint-1, eval = FALSE}
x <- "alfa,bravo,charlie,delta"
strsplit(x, split = ",")[[...]]
```

```{r, include=FALSE}
x <- "alfa,bravo,charlie,delta"
strsplit(x, split = ",")[[1]]
```

### 

This double bracket operator (`[[`) allows us to extract single elements from a list, in this case achieving the same effect as the `unlist()` function.

### Exercise 8

Another way to achieve this effect is to just create a function. Click "Run Code" to create the convenience function `strsplit1()`.

```{r write-the-first-func-8, exercise = TRUE}
strsplit1 <- function(x, split) {
  strsplit(x, split = split)[[1]]
}
```

### 

This tutorial will not go into detail about how functions work, but please refer to chapter 26 of the [*R for Data Science (2e)*](https://r4ds.hadley.nz/quarto.html) book by Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund for more information.

### Exercise 9

Take the code from Exercise 3 and replace `strsplit()` with `strsplit1()`, the function we just created.

```{r write-the-first-func-9, exercise = TRUE}

```

```{r write-the-first-func-9-hint-1, eval = FALSE}
x <- "alfa,bravo,charlie,delta"
strsplit1(x, split = ...)
```

```{r, include=FALSE}
x <- "alfa,bravo,charlie,delta"
strsplit1(x, split = ",")
```

### 

Notice how now, it "unlists" the output with just one command.

### Exercise 10

In the Console, type the command `use_r()` with the argument `"strsplit1"`. 

### 

In the Terminal, type `ls R` and CP/CR.

```{r write-the-first-func-10}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

The helper `use_r()` creates and/or opens a script below `R/`. You should see a new file listed called `strsplit1.R`.

### Exercise 11

Recalling the code from exercise 8:

```
strsplit1 <- function(x, split) {
  strsplit(x, split = split)[[1]]
}

```
Copy and paste it into the new `strsplit1.R` file and save the file.

### 

Now, run `cat R/strsplit1.R` in the Terminal and CP/CR.

```{r write-the-first-func-11}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

The file `R/strsplit1.R` should NOT contain any of the other top-level code we have recently executed, such as the definition of our practice input `x` or `library(devtools)`.

## Loading and Checking
### 

For package development, **devtools** offers a more robust approach towards testing our functions.

### Exercise 1

Call `load_all()` in the Console to make `strsplit1()` available for use. CP/CR

```{r loading-and-checking-1}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

`load_all()` simulates the process of building, installing, and attaching the **regexcite** package.

### Exercise 2

Run this line of code in the Console: `exists("strsplit1", where = globalenv(), inherits = FALSE)`

```{r loading-and-checking-2}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

Note that we want this to read `FALSE` because we want it to use the **regexcite** package. If you see `TRUE`, it means that `strsplit1()` is sourced from the function you defined in the console. 

### 

If it reads `TRUE`, restart your R session, reload in the **devtools** library, and rerun `load_all()`.

### 

Now, `strsplit1()` should work without errors and `exists("strsplit1", where = globalenv(), inherits = FALSE)` should return `FALSE`.

### Exercise 3

Check box next to `R/strsplit1()` in the upper right hand Git tab and press "Commit".

### 

Write a message like "Added first function to package", press "Commit", and press "Push".

### 

Run `git log` in the Terminal and CP/CR.

```{r loading-and-checking-3}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

Because of `load_all()`, we now have informal, empirical evidence that `strsplit1()` works.

### Exercise 4

Visit the help page for `check()` by typing `?check` in the Console and selecting the **devtools** version.

### 

Copy and paste the second paragraph in the "Description" section.

```{r loading-and-checking-4}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

`R CMD check`, executed in the shell, is the gold standard for checking that an R package is in full working order. `check()` is a convenient way to run this without leaving your R session.

### Exercise 5

Run `check()` in the Console and only CP/CR the `R CMD check results` section.

```{r loading-and-checking-5}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

It is **essential** to actually read the output of the check! Deal with problems early and often. It’s just like incremental development of `.R` and `.Rmd` files. The longer you go between full checks that everything works, the harder it becomes to pinpoint and solve your problems.

### Exercise 6

CP/CR the warning you received in the `R CMD check results`.

```{r loading-and-checking-6}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

You should have received `0` errors, `0` notes, and this warning about licenses: 

```
Non-standard license specification:
  `use_mit_license()`, `use_gpl3_license()` or friends to pick a
  license
```
This warning has to do with the `DESCRIPTION` file which we will address shortly by doing just as it says.

### Exercise 7

Run `cat DESCRIPTION` in the Terminal and CP/CR.

```{r loading-and-checking-7}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

The DESCRIPTION file provides metadata about your package. You’ll see it’s populated with boilerplate content, which needs to be replaced.

### Exercise 8

Open up the `DESCRIPTION` file and replace the `"First"` under the `Authors@R:` field with your first name.

### 

Run `cat DESCRIPTION` and CP/CR.

```{r loading-and-checking-8}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

Every package must have a `DESCRIPTION.` In fact, it’s the defining feature of a package (RStudio and **devtools** consider any directory containing `DESCRIPTION` to be a package).

### Exercise 9

Now, in the `DESCRIPTION` file, replace the `"Last"` placeholder under the `Authors@R:` field with your last name.

### 

Run `cat DESCRIPTION` and CP/CR.

```{r loading-and-checking-9}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

`DESCRIPTION` uses a simple file format called DCF, the Debian control format. Each line consists of a field name and a value, separated by a colon.

### Exercise 10

Replace the `"first.last@example.com"` placeholder with your email, and delete the portion under the `Authors@R` field that says `comment = c(ORCID = "YOUR-ORCID-ID")`.

### 

Run `cat DESCRIPTION` and CP/CR.

```{r loading-and-checking-10}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

If you create a lot of packages, you can customize the default content of new `DESCRIPTION` files by setting the global option `usethis.description` to a named list. Visit [this article](https://usethis.r-lib.org/articles/usethis-setup.html) for more information.

### Exercise 11

Lastly, fill in the `Title` field (e.g. "Make Regular Expressions More Exciting") and the `Description` field (e.g. "Convenience functions to make some common tasks with string manipulation and regular expressions a bit easier.")

### 

Run `cat DESCRIPTION` and CP/CR.

```{r loading-and-checking-11}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

Note that we currently have a placeholder in the `License` field of `DESCRIPTION` that’s deliberately invalid and suggests a resolution.

### Exercise 12

In the Console, run `use_mit_license()`. CP/CR.

```{r loading-and-checking-12}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

This configures the `License` field correctly for the MIT license, which promises to name the copyright holders and year in a `LICENSE` file.

### Exercise 13

In the Terminal, run `ls`. CP/CR.

```{r loading-and-checking-13}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

Notice that the `use_mit_license()` function has generated new `LICENSE` and `LICENSE.md` files.

### Exercise 14

Run `cat LICENSE` in the Terminal. CP/CR.

```{r loading-and-checking-14}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

The file should look something like this:

```
YEAR: 2023
COPYRIGHT HOLDER: regexcite authors
```

### 

Like other license helpers, `use_mit_license()` also puts a copy of the full license in `LICENSE.md` and adds this file to `.Rbuildignore`. It’s considered a best practice to include a full license in your package’s source, such as on GitHub, but CRAN disallows the inclusion of this file in a package tar file.

### Exercise 15

Now, run `check()` again and copy the `R CMD check results` section.

```{r loading-and-checking-15}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

You should now have no errors, warnings, or notes!

### Exercise 16

Check the boxes next to `LICENSE.md`, `LICENSE`, `DESCRIPTION`, and `.Rbuildignore` in the Git tab and press "Commit".

### 

In the box, write a commit message (e.g. "Configured DESCRIPTION and set license") and press "Push".

### 

Run `git log` in the Terminal and CP/CR.

```{r loading-and-checking-16}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

If you visit the Github website, you should see the new files you just pushed.

## Documenting and Installing
### 

Wouldn’t it be nice to get help on `strsplit1()`, just like we do with other R functions? This requires that your package have a special R documentation file, `man/strsplit1.Rd`, written in an R-specific markup language.

### Exercise 1

Recall our `R/strsplit1.R` file. Run `cat R/strsplit1.R` in the Terminal and CP/CR.

```{r documenting-and-inst-1}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

We write a specially formatted comment right above `strsplit1()`, in its source file, and then let a package called **roxygen2** handle the creation of `man/strsplit1.Rd`.

### Exercise 2

Open the `strsplit1.R` file in the `R` directory and click your cursor somewhere inside the `strsplit1()` function definition.

### 

Now, navigate to "Code" in the upper left hand corner of RStudio, and select "Insert roxygen skeleton".

### 

Copy every line that starts with `#'` and paste it below.

```{r documenting-and-inst-2}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

The starting skeleton should look something like this: 

```
# ' Title
# '
# ' @param x 
# ' @param split 
# '
# ' @return
# ' @export
# '
# ' @examples
```

RStudio only inserts a barebones template, so we will need to edit it manually.

### Exercise 3

Replace the line that says "Title" with a overall title for the function, (e.g. "Split a string"). Note that you should still keep the "#' " in front of it.

### 

Copy every line that starts with `#'` and paste it below.

```{r documenting-and-inst-3}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

Note that it is possible to insert this skeleton manually if for some reason you are not using RStudio. 

### Exercise 4

Now, for each parameter, add a short description. To do this, add a space to the end of each line that has `@param` and write what each parameter represents. (e.g. "@param x A character vector with one element." and "@param split What to split on.")

### 

Copy every line that starts with `#'` and paste it below.

```{r documenting-and-inst-4}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

In the **devtools** ecosystem, we don’t edit `.Rd` files directly with our bare hands.

### 

Instead, we include specially formatted “roxygen comments” above the source code for each function. Then we use the **roxygen2** package to generate the `.Rd` files from these special comments.

### Exercise 5

Next to the `@return` line, describe what the function returns (e.g. "@return A character vector")

### 

Lastly, add an example in a new line under the `@examples` line. We will use the original code we tested `strsplit1()` on. For example,

```
# ' @examples
# ' x <- "alfa,bravo,charlie,delta"
# ' strsplit1(x, split = ",")
```

### 

Copy every line that starts with `#'` and paste it below.

```{r documenting-and-inst-5}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

But we’re not done yet! We still need to trigger the conversion of this new roxygen comment into `man/strsplit1.Rd`

### Exercise 6

In the Console, run the command `document()`. CP/CR

```{r documenting-and-inst-6}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

Note that in the Console output, it is not only writing the `strsplit1.Rd` file, but also writing to the `NAMESPACE` file. We will be addressing this shortly.

### Exercise 7

Run `ls` in the Terminal. CP/CR.

```{r documenting-and-inst-7}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

Take note that the `document()` command has created a new `man` directory.

### Exercise 8

Run `cat man/strsplit1().Rd` in the Terminal.

```{r documenting-and-inst-8}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

You should see a lot of `{}` and `\`, this is the custom syntax of `.Rd` files which can be rendered to HTML, plain text, or pdf, as needed, for viewing in different contexts. 

### Exercise 9

Now, that we've documented our function, we have access to a help page for it! Visit it by first running `load_all()` in the Console and typing `?strsplit1` in the Console and CP/CR.

```{r documenting-and-inst-9}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

You’ll see a message like “Rendering development documentation for ‘strsplit1’”, which reminds that you are basically previewing draft documentation. That is, this documentation is present in your package’s source, but is not yet present in an installed package.

### Exercise 10

Now, run `cat NAMESPACE` in the Terminal since `document()` has changed it. CP/CR.

```{r documenting-and-inst-10}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

You should see a `export(strsplit1)`. The export directive in `NAMESPACE` is what makes `strsplit1()` available to a user after attaching **regexcite** via `library(regexcite)`. Just as it is entirely possible to author `.Rd` files “by hand”, you can manage `NAMESPACE` explicitly yourself. But we choose to delegate this to **devtools** (and **roxygen2**).

### Exercise 11

Now that we have a minimum viable product, let's install the **regexcite** package into our library by typing `install()` into the Console. CP/CR.

```{r documenting-and-inst-11}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

After installation is complete, we can attach and use **regexcite** like any other package. This is also a good time to restart your R session and ensure you have a clean workspace.

### Exercise 12

In the Console, load in the **regexcite** package like you would any other package using `library()`. 

### 

Now, copy and run the original testing code we used before in the Console.

```
x <- "alfa,bravo,charlie,delta"
strsplit1(x, split = ",")
```

CP/CR.

```{r documenting-and-inst-12}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

Note that now we don't need to use `load_all()` anymore and it functions as a regular package!

### Exercise 13

Navigate to the Git tab in the upper right corner, check every box, and press "Commit".

### 

Write a short commit message (e.g. "Documented package"), press "commit" and "Push".

### 

Run `git log` in the Terminal and CP/CR.

```{r documenting-and-inst-13}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

You should now see your new changes on the Github website under your repository!

## Testing and Using other packages
### 

We’ve tested `strsplit1()` informally, in a single example. We can formalize this as a unit test. This means we express a concrete expectation about the correct `strsplit1()` result for a specific input.

### Exercise 1

Run `use_testthat()` in the Console and CP/CR.

```{r testing-and-using-ot-1}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

This initializes the unit testing machinery for your package. However, it’s still up to YOU to write the actual tests!

### Exercise 2

Run `cat DESCRIPTION` in the Terminal. CP/CR

```{r testing-and-using-ot-2}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

You should notice a new entry under the Suggests field that says `testthat` with some minimum version (e.g. `>= 3.0.0`).

### Exercise 3

Run `ls` in the Terminal. CP/CR

```{r testing-and-using-ot-3}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

Notice that there is a new `tests` directory. Inside this folder is another `testthat` directory that will hold our unit tests.

### Exercise 4

Run `use_test()` in the Console with the argument `"strsplit1"` and CP/CR.

```{r testing-and-using-ot-4}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

The helper `use_test()` opens and/or creates a test file. You can provide the file’s basename or, if you are editing the relevant source file in RStudio, it will be automatically generated.

### Exercise 5

Run `ls tests/testthat/` in the Terminal. CP/CR.

```{r testing-and-using-ot-5}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

You should see a new `.R` file called `test-strsplit1.R`. If it had already existed, `use_test()` would have just opened it.

### Exercise 6

Open up the `test-strsplit1.R` file and delete the example test code.

### 

Replace the code with this test code:

```
test_that("strsplit1() splits a string", {
  expect_equal(strsplit1("a,b,c", split = ","), c("a", "b", "c"))
})
```
### 

Run the above test code in the Console and CP/CR.

```{r testing-and-using-ot-6}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

You should have seen "Test Passed". If `test_that()` or `strsplit1()` can’t be found, that suggests that you probably need to call `load_all()`.

### Exercise 7

Run `test()` in the Console and CP/CR.

```{r testing-and-using-ot-7}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

You should see something like this:

```
test()
# > ℹ Testing regexcite
# > ✔ | F W S  OK | Context
# > 
# > ⠏ |         0 | strsplit1                                           
# > ✔ |         1 | strsplit1
# > 
# > ══ Results ═════════════════════════════════════════════════════════
# > [ FAIL 0 | WARN 0 | SKIP 0 | PASS 1 ]
```

Note that your tests are also run whenever you `check()` the package. In this way, you basically augment the standard checks with some of your own, that are specific to your package.

### Exercise 8

Let’s imagine you decide you’d rather build **regexcite** based on **stringr** than on base R’s regular expression functions.

### 

First, declare your general intent to use some functions from the **stringr** namespace with `use_package()`

### 

Call `use_package()` with `"stringr"` as the argument in the Console. CP/CR.

```{r testing-and-using-ot-8}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

The **stringr** package “provides a cohesive set of functions designed to make working with strings as easy as possible”. 


### Exercise 9

Run `cat DESCRIPTION` in the Terminal. CP/CR.

```{r testing-and-using-ot-9}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

Note that the `use_package()` function adds the **stringr** package to the `Imports` field of DESCRIPTION. That is all it does.

### Exercise 10

Revisit the `strsplit1.R` file and replace the existing function definition with a new one (make sure to keep all the `#'` lines):

```
str_split_one <- function(string, pattern, n = Inf) {
  stopifnot(is.character(string), length(string) <= 1)
  if (length(string) == 1) {
    stringr::str_split(string = string, pattern = pattern, n = n)[[1]]
  } else {
    character()
  }
}
```

Run `cat R/strsplit1.R` in the Terminal. CP/CR.


```{r testing-and-using-ot-10}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

These changes are mostly to make the function more "stringr-like". For example, we rename the function to `str_split_one()`, to signal that that is a wrapper around `stringr::str_split()` and Use the `package::function()` form when calling `stringr::str_split()`.

### Exercise 11

However, now the file names and the function names don't match!

### 

Call the command `rename_files()` with the arguments `"strsplit1"`, and `"str_split_one"` in that order.

```{r testing-and-using-ot-11}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

Of course, this file name work only affects the names, we will still need to update the contents of the files!

### Exercise 12

Open up the `str_split_one.R` file in the `R/` directory. Notice how although it is fully updated to the **stringr** package, the roxygen header is still obsolete.

### 

Replace the entire roxygen header with this:

```
# ' Split a string
# '
# ' @param string A character vector with, at most, one element.
# ' @inheritParams stringr::str_split
# '
# ' @return A character vector.
# ' @export
# '
# ' @examples
# ' x <- "alfa,bravo,charlie,delta"
# ' str_split_one(x, pattern = ",")
# ' str_split_one(x, pattern = ",", n = 2)
# '
# ' y <- "192.168.0.1"
# ' str_split_one(y, pattern = stringr::fixed("."))
```
### 

Run `cat R/str_split_one.R` in the Terminal and CP/CR.

```{r testing-and-using-ot-12}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

We won't cover the details of how the new function works, but it is important to note that we need to change the roxygen header as we edit the function itself. 

### Exercise 13

Don't forget that we have to update the test file now too!

### 

Open up `tests/testthat/test-str_split_one.R` and replace the existing test with the below:

```
test_that("str_split_one() splits a string", {
  expect_equal(str_split_one("a,b,c", ","), c("a", "b", "c"))
})

test_that("str_split_one() errors if input length > 1", {
  expect_error(str_split_one(c("a,b","c,d"), ","))
})

test_that("str_split_one() exposes features of stringr::str_split()", {
  expect_equal(str_split_one("a,b,c", ",", n = 2), c("a", "b,c"))
  expect_equal(str_split_one("a.b", stringr::fixed(".")), c("a", "b"))
})
```

### 

Run `cat tests/testthat/test-str_split_one.R` and CP/CR.

```{r testing-and-using-ot-13}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

In addition to the change in the function’s name and arguments, we’ve added a couple more tests.

### Exercise 14

Now that we've edited our roxygen comments and made use of another package, we need to call `document()` again.

### 

Run `document()` in the Console and CP/CR.

```{r testing-and-using-ot-14}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

You should see something like this: 

```
> document()
ℹ Updating regexcite documentation
ℹ Loading regexcite
Warning: Objects listed as exports, but not present in namespace:
• strsplit1
Writing 'NAMESPACE'
Writing 'str_split_one.Rd'
Deleting 'strsplit1.Rd'
```

Don’t be dismayed by the warning about `"Objects listed as exports, but not present in namespace: strsplit1"`. That always happens when you remove something from the namespace.

### Exercise 15

Let's try out our new function!

### 

Run `load_all()` in the Console.

### 

Call this command in the Console to try out the new function: `str_split_one("a, b, c", pattern = ", ")`

CP/CR.

```{r testing-and-using-ot-15}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

As you can see, our function works exactly the same, but we know the inner working are altered.

### Exercise 16

Navigate to the "Git" tab, check every box, and press "Commit".

###

Write a commit message (e.g. "Added tests and introduced stringr"), press "Commit", and "Push".

###

Run `git log` in the Terminal and CP/CR.

```{r testing-and-using-ot-16}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

Visit your GitHub Repo to see all your new changes!

## The README file
### 

As your package is on GitHub, the README.md file matters. It is the package's home page and welcome mat.

### Exercise 1

Call `use_readme_rmd()` in the Console. CP/CR.

```{r the-readme-file-1}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

In addition to creating `README.Rmd`, this adds some lines to `.Rbuildignore`, and creates a Git pre-commit hook to help you keep `README.Rmd` and `README.md` in sync.

### Exercise 2

Run `cat README.Rmd` in the Terminal and CP/CR.

```{r the-readme-file-2}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

We like to write the `README` in R Markdown, so it can feature actual usage. The inclusion of live code also makes it less likely that your `README` grows stale and out-of-sync with your actual package.

### Exercise 3

Let's alter the default `README.Rmd` for our package.

### 

Starting with the `regexcite` section, replace the "The goal of regexcite..." line with the following: 

```
The goal of regexcite is to make regular expressions more exciting!
It provides convenience functions to make some common tasks with string manipulation and regular expressions a bit easier.
```

### 

Next, leaving the "Installation" section alone, delete the entire "Example" section.

### 

Run `cat README.Rmd` in the Terminal and CP/CR.

```{r the-readme-file-3}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

We are going to replace the default "Example" section with a "Usage" section that walks the user through our function.

### Exercise 4

A few lines below the "Installation" section, add two "#" and type "Usage" to create a new section.

### 

Paste the following under the double "#" header

```

A fairly common task when dealing with strings is the need to split a single string into many parts.
This is what `base::strplit()` and `stringr::str_split()` do.

```

### 

Next, click the green "C" in the upper right corner of the tab to create a new code chunk and select "R".

### 

In this code chunk, paste the following: 

```
(x <- "alfa,bravo,charlie,delta")
strsplit(x, split = ",")
stringr::str_split(x, pattern = ",")
```

### 

Run `cat README.RMD` and CP/CR.

```{r the-readme-file-4}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

Recall that this was the base version of `str_split` that we sought to improve with our package!

### Exercise 5

Under the code chunk, paste the following:

```
Notice how the return value is a **list** of length one, where the first element holds the character vector of parts.
Often the shape of this output is inconvenient, i.e. we want the un-listed version.

That's exactly what `regexcite::str_split_one()` does.

```
### 

Now, add a new R code chunk and paste the following in it to demonstrate our function:

```
library(regexcite)

str_split_one(x, pattern = ",")
```

### 

Under that, we can add some text to further explain the function:

```
Use `str_split_one()` when the input is known to be a single string.
For safety, it will error if its input has length greater than one.

`str_split_one()` is built on `stringr::str_split()`, so you can use its `n` argument and stringr's general interface for describing the `pattern` to be matched.
```
### 

Lastly, add another R code chunk and paste this code in it:

```
str_split_one(x, pattern = ",", n = 2)

y <- "192.168.0.1"
str_split_one(y, pattern = stringr::fixed("."))
```

This code should further demonstrate the capabilities of `str_split_one()`.

### 

Run `cat README.Rmd` and CP/CR.

```{r the-readme-file-5}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

However, we still need to update the `README.md`! To do this, we need to render the `README.Rmd` file.

### Exercise 6

Run `build_readme()` in the Console to render the `README.Rmd` file. CP/CR.

```{r the-readme-file-6}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

Now that we have updated the `README.md`, we should see the updated page after pushing our changes to GitHub.

### Exercise 7

Check all the boxes under the git tab in the upper right hand corner, press "Commit", and write a message (e.g. "Wrote README file").

### 

Now, press "Commit" and "Push".

### 

Run `git log` in the Terminal and CP/CR.

```{r the-readme-file-7}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

If you visit your GitHub Repo page, you should see a new `README.md` completely formatted complete with code blocks!

## Summary
### 

This tutorial covered [Chapter 1: The Whole Game](https://r-pkgs.org/whole-game.html) from [*R Packages (2e)*](https://r-pkgs.org/) by [Hadley Wickham](https://hadley.nz/) and [Jennifer Bryan](https://jennybryan.org/). [**devtools**](https://devtools.r-lib.org/) is a package designed to make package development easier by providing R functions that simplify and expedite common tasks.

```{r download-answers, child = system.file("child_documents/download_answers.Rmd", package = "tutorial.helpers")}
```
